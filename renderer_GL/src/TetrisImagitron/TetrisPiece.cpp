/**
 *	Eduardo Ceretta Dalla Favera
 *  eduardo.ceretta@gmail.com
 *  Apr 2015  
 *
 *  TetrisPiece.
 */

#include "TetrisPiece.h"
#include <assert.h>
#include <algorithm>

std::map<unsigned int, std::pair<TetrisPiece::PieceType, float> > TetrisPiece::s_hashmap;

TetrisPiece::TetrisPiece()
:m_processed(false)
,m_rot_angle(0.0f)
,m_type(TetrisPiece::PieceType::O)
{
  if(s_hashmap.empty()) {
    createHashMap();
  }
}

void TetrisPiece::setBlock(const Vector3 v, const unsigned int i)
{
  assert(i <= 3);
  m_blocks[i] = v;
}


void TetrisPiece::process()
{
  if(m_processed) return;
  const bool **m = getOriginMatrix();
  unsigned int hash = getHash(m);

  m_type = s_hashmap[hash].first;
  m_rot_angle = s_hashmap[hash].second;

  m_processed = true;
}

const bool** TetrisPiece::getOriginMatrix() const
{
  Vector3 min_p = m_blocks[0];
  for (int i = 0; i < 4; ++i) {
    min_p.x = std::min(m_blocks[i].x, min_p.x);
    min_p.y = std::min(m_blocks[i].y, min_p.y);
  }

  bool **m = new bool*[4];
  for (int i = 0; i< 4; ++i) {
    m[i] = new bool[4];
    memset(m[i], false, 4*sizeof(bool));
  }

  for (int i = 0; i < 4; ++i) {
    Vector3 origin = m_blocks[i] - min_p;
    m[(int)origin.y][(int)origin.x] = true;
  }

  return (const bool **)m;
}

unsigned int TetrisPiece::getHash( const bool** m ) const
{
  unsigned int hash = 0;
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
      if (m[i][j]) {
        hash += (1 << (i*4+j));
      }
    }
  }
  return hash;
}

void TetrisPiece::createHashMap()
{
  //Generated by perl piece_hasher.pl
  s_hashmap[4369] = std::pair<PieceType, float> (PieceType::I, 0.0f   );
  s_hashmap[15]   = std::pair<PieceType, float> (PieceType::I, 90.0f  );
  s_hashmap[275]  = std::pair<PieceType, float> (PieceType::L, 0.0f   );
  s_hashmap[71]   = std::pair<PieceType, float> (PieceType::L, 90.0f  );
  s_hashmap[802]  = std::pair<PieceType, float> (PieceType::L, 180.0f );
  s_hashmap[113]  = std::pair<PieceType, float> (PieceType::L, -90.0f );
  s_hashmap[547]  = std::pair<PieceType, float> (PieceType::J, 0.0f   );
  s_hashmap[23]   = std::pair<PieceType, float> (PieceType::J, 90.0f  );
  s_hashmap[785]  = std::pair<PieceType, float> (PieceType::J, 180.0f );
  s_hashmap[116]  = std::pair<PieceType, float> (PieceType::J, -90.0f );
  s_hashmap[54]   = std::pair<PieceType, float> (PieceType::Z, 0.0f   );
  s_hashmap[561]  = std::pair<PieceType, float> (PieceType::Z, 90.0f  );
  s_hashmap[99]   = std::pair<PieceType, float> (PieceType::S, 0.0f   );
  s_hashmap[306]  = std::pair<PieceType, float> (PieceType::S, 90.0f  );
  s_hashmap[114]  = std::pair<PieceType, float> (PieceType::T, 0.0f   );
  s_hashmap[562]  = std::pair<PieceType, float> (PieceType::T, 90.0f  );
  s_hashmap[39]   = std::pair<PieceType, float> (PieceType::T, 180.0f );
  s_hashmap[305]  = std::pair<PieceType, float> (PieceType::T, -90.0f );
  s_hashmap[51]   = std::pair<PieceType, float> (PieceType::O, 0.0f   );
}